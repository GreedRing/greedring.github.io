<!DOCTYPE html>
<html>

<head><meta name="generator" content="Hexo 3.9.0">
  
  <title>IO流 - Greed Ring</title>
  <meta charset="UTF-8">
  <meta name="description" content>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  

  <link rel="shortcut icon" href="/favicon.png" type="image/png">
  <meta name="description" content="字符流、字节流、缓冲流、转化流、其他流">
<meta name="keywords" content="JavaSE">
<meta property="og:type" content="article">
<meta property="og:title" content="IO流">
<meta property="og:url" content="http://greedring.com/2019/09/17/JavaSE20/index.html">
<meta property="og:site_name" content="Greed Ring">
<meta property="og:description" content="字符流、字节流、缓冲流、转化流、其他流">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-09-22T18:10:09.411Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="IO流">
<meta name="twitter:description" content="字符流、字节流、缓冲流、转化流、其他流">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdui@0.4.3/dist/css/mdui.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.15.8/styles/atom-one-dark.css">
   
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1038733_0xvrvpg9c0r.css">
  <link rel="stylesheet" href="/css/style.css?v=1569175824266">
<link rel="stylesheet" href="\assets\css\APlayer.min.css" class="aplayer-style-marker">
<script src="\assets\js\APlayer.min.js" class="aplayer-script-marker"></script>
<script src="\assets\js\Meting.min.js" class="meting-script-marker"></script>
</head>

<body class="mdui-drawer-body-left">
  
  <div id="nexmoe-background">
    <div class="nexmoe-bg" style="background-image: url(https://i.loli.net/2019/08/22/IxAp3mfcJWbzaFU.jpg)"></div>
    <div class="mdui-appbar mdui-shadow-0">
      <div class="mdui-toolbar">
        <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">menu</i></a>
        <div class="mdui-toolbar-spacer"></div>
        <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
        <a href="/" title="GreedRing" class="mdui-btn mdui-btn-icon"><img src="/images/avatar.png"></a>
       </div>
    </div>
  </div>
  <div id="nexmoe-header">
      <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="GreedRing">
            <img src="/images/avatar.png" alt="GreedRing">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>文章</span>26</div>
        <div><span>标签</span>3</div>
        <div><span>分类</span>2</div>
    </div>
    <ul class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/about.html" title="关于博客">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                关于博客
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/friends.html" title="我的朋友">
            <i class="mdui-list-item-icon nexmoefont icon-unorderedlist"></i>
            <div class="mdui-list-item-content">
                我的朋友
            </div>
        </a>
        
    </ul>
    <aside id="nexmoe-sidebar">
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">社交按钮</h3>
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://space.bilibili.com/15144854" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/greedring/" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a>
    </div>
</div>
  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章分类</h3>
    <div class="nexmoe-widget">

      <ul class="category-list">

        


        

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Java/">Java</a>
          <span class="category-list-count">24</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/设计模式/">设计模式</a>
          <span class="category-list-count">1</span>
        </li>

        
      </ul>

    </div>
  </div>


  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">标签云</h3>
    <div id="randomtagcloud" class="nexmoe-widget tagcloud">
      <a href="/tags/JavaSE/" style="font-size: 20px;">JavaSE</a> <a href="/tags/JavaSE练习/" style="font-size: 15px;">JavaSE练习</a> <a href="/tags/桥接模式/" style="font-size: 10px;">桥接模式</a>
    </div>
    
  </div>

  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章归档</h3>
    <div class="nexmoe-widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li></ul>
    </div>
  </div>


  
</aside>
    <div class="nexmoe-copyright">
        &copy; 2019 GreedRing
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://nexmoe.com/hexo-theme-nexmoe.html" target="_blank">Nexmoe</a>
    </div>
</div><!-- .nexmoe-drawer -->
  </div>
  <div id="nexmoe-content">
    <div class="nexmoe-primary">
        <div class="nexmoe-post">
    <div class="nexmoe-post-cover"> 
        
        <img src="https://i.loli.net/2019/09/21/NyYscOljraoSp24.jpg">
        
        <h1>IO流</h1>
    </div>
  <div class="nexmoe-post-meta">
    <a><i class="nexmoefont icon-calendar-fill"></i>2019年09月17日</a>
    <a><i class="nexmoefont icon-areachart"></i>5.7k 字</a>
    <a><i class="nexmoefont icon-time-circle-fill"></i>大概 28 分钟</a>
    
      <a class="nexmoefont icon-appstore-fill -link" href="/categories/Java/">Java</a>
    
    
      <a class="nexmoefont icon-tag-fill -link" href="/tags/JavaSE/">JavaSE</a>
    
  </div>
  <article>
    <p>字符流、字节流、缓冲流、转化流、其他流</p>
<a id="more"></a>


    <div id="aplayer-ioMGGNuN" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="27580979" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div>

<h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><p>用来处理设备间的数据传输，Java对数据的操作是通过流的方式，Java用于操作流的类都在IO包中</p>
<blockquote>
<p>流按流向分为：输入流、输出流<br>流按照操作内容分为：字节流、字符流</p>
</blockquote>
<h4 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h4><p>File文件和目录路径名的抽象表示形式<br>即：Java中把文件或者目录（文件夹）都封装成File类<br>也就是说如果我们要去操作硬盘上的文件,或者文件夹只要找到File这个类即可。</p>
<p><strong>1.文件路径</strong></p>
<blockquote>
<p>绝对路径：从盘符开始到文件的路径。D:\\code\\greedring\\day20.java [文件分隔符\\（转义）]<br>相对路径：从某个参照路径开始到指定文件所经过的路径。 相对于 D:\\code\\greedring，相对路径 day20.java</p>
</blockquote>
<p>&emsp;<strong>构造方法：</strong></p>
<ul>
<li>File(String pathname)<br>通过将给定的路径名的字符串转换成一个抽象路径名创建一个新的 File实例。</li>
<li>File(String parent, String child)<br>创建从父路径名的字符串和一个孩子的一个新的 File实例文件。</li>
<li>File(File parent, String child)<br>创建从一个家长的抽象路径名和一个孩子的路径字符串的新 File实例。</li>
</ul>
<p><strong>2.文件分割符</strong><br>Windows: <br>Unix(Linux、Mac OS): /</p>
<blockquote>
<p>获取系统默认的文件分隔符：&emsp;<label style="color:#ff4e6a">File.separator</label><br>System.out.println(“D:”+File.separator+”Test.txt”);</p>
</blockquote>
<p><strong><label style="color:#ff4e6a">常用方法：</label></strong><br><strong>(1).获取方法：</strong></p>
<ul>
<li>public String &emsp;<label style="color:#ff4e6a">getAbsolutePath()</label><br>获取绝对路径</li>
</ul>
<ul>
<li>public String &emsp;<label style="color:#ff4e6a">getPath()</label><br>获取路径(用什么方式创建的对象,就返回什么方式的路径(绝对路径/相对路径))</li>
</ul>
<ul>
<li>public String &emsp;<label style="color:#ff4e6a">getName()</label><br>获取文件/文件夹的名称</li>
</ul>
<ul>
<li>public String &emsp;<label style="color:#ff4e6a">getParent()</label><br>返回所在文件夹路径(根据创建对象时是否为绝对路径/相对路径)</li>
</ul>
<ul>
<li>long &emsp;<label style="color:#ff4e6a">lastModified()</label><br>返回文件的抽象路径名表示上次修改时间。（时间戳 毫秒）</li>
</ul>
<ul>
<li>long &emsp;<label style="color:#ff4e6a">length()</label><br>返回文件的抽象路径名表示的大小</li>
</ul>
<p><strong>(2).创建与删除</strong></p>
<ul>
<li>public boolean &emsp;<label style="color:#ff4e6a">createNewFile() throws IOException</label><br>创建文件</li>
</ul>
<p>&emsp;&emsp;<strong>在创建文件时,如果文件所在的文件夹不存在,则报错系统找不到指定的路径.创建文件时,必须确保文件夹已经存在</strong></p>
<ul>
<li>public boolean &emsp;<label style="color:#ff4e6a">mkdir()</label><br>使用mkdir方法创建文件夹时,必须保证其所在文件夹已经存在,否则创建失败(不会报错)</li>
</ul>
<ul>
<li>public boolean &emsp;<label style="color:#ff4e6a">mkdirs()</label><br>一次性创建多级目录</li>
</ul>
<ul>
<li>public boolean &emsp;<label style="color:#ff4e6a">delete()</label><br>删除文件夹必须为空（未存储东西）,否则删除失败</li>
</ul>
<p><strong>(3).判断</strong></p>
<ul>
<li>public boolean &emsp;<label style="color:#ff4e6a">exists()</label><br>文件或者文件夹是否存在</li>
</ul>
<ul>
<li>public boolean &emsp;<label style="color:#ff4e6a">isDirectory()</label><br>判断文件对象是否为文件夹</li>
</ul>
<ul>
<li>public boolean &emsp;<label style="color:#ff4e6a">isFile()</label><br>判断文件对象是否为文件</li>
</ul>
<p><strong>(4).获取目录下的结构(必须是目录对象调用)</strong></p>
<ul>
<li>public File[] &emsp;<label style="color:#ff4e6a">listFiles()</label><br>获取调用方法文件夹下的所有file对象(文件或文件夹)</li>
</ul>
<ul>
<li>public String[] &emsp;<label style="color:#ff4e6a">list()</label><br>返回的字符串在该目录下的抽象路径名的文件和目录命名为数组</li>
</ul>
<pre><code class="java">package com.greedring;

import java.io.File;
import java.io.IOException;
import java.util.Date;

public class Test {
    public static void main(String[] args) {
        File file01 = new File(&quot;Test.txt&quot;);
        System.out.println(file01.getAbsolutePath());
        System.out.println(file01.getPath());
        System.out.println(file01.getName());
        System.out.println(file01.getParent());
        System.out.println(new Date(file01.lastModified()));
        System.out.println(file01.length());

        System.out.println(&quot;====================&quot;);

        File file02 = new File(&quot;D:\\Test\\Test1.txt&quot;);
        System.out.println(file02.getAbsolutePath());
        System.out.println(file02.getPath());
        System.out.println(file02.getName());
        System.out.println(file02.getParent());
        System.out.println(new Date(file02.lastModified()));
        System.out.println(file02.length());

        System.out.println(&quot;=====创建与删除=====&quot;);

        //创建文件,保证文件所在的文件夹必须存在（否则抛出IOException）
        File file03 = new File(&quot;D:\\Test\\Test2.txt&quot;);
        try {
            //创建文件
            boolean createNewFile = file03.createNewFile();
            System.out.println(createNewFile);
        } catch (IOException e) {
            e.printStackTrace();
        }

        System.out.println(&quot;====================&quot;);

        File file04 = new File(&quot;D:\\Test\\Test01&quot;);
        //创建目录,前提需要创建的目录所在的目录必须存在
        boolean mkdir = file04.mkdir();
        System.out.println(mkdir);

        System.out.println(&quot;====================&quot;);

        File file05 = new File(&quot;D:\\Test\\Test02\\Test&quot;);
        //创建目录,如果需要创建的目录所在的目录不存在，也会默认创建
        boolean mkdirs = file05.mkdirs();
        System.out.println(mkdirs);

        System.out.println(&quot;====================&quot;);

        File file06 = new File(&quot;D:\\Test\\Test2.txt&quot;);
        //删除文件
        boolean delete = file06.delete();
        System.out.println(delete);

        System.out.println(&quot;====================&quot;);

        File file07 = new File(&quot;D:\\Test\\Test02\\Test&quot;);
        //删除目录，若当前目录不为空，则删除失败（处理：递归）
        boolean delete2 = file07.delete();
        System.out.println(delete2);

        /*
        //递归演示
        //求N阶乘
        private static int factorial(int i) {
            if (i == 1) {
                return 1;
            } else {
                return i * factorial(i - 1);
            }
        }

        //打印一个文件夹内所有的文件路径
        private static void printFile(File file) {
            if (file.isFile()) {
                System.out.println(file.getName());
            } else if (file.isDirectory()) {
                System.out.println(&quot;Dir:&quot; + file.getName());

                //获取目录下的子文件对象
                File[] listFiles = file.listFiles();
                for (File f : listFiles) {
                    printFile(f);
                }
            }
        }

        //删除一个文件夹（包含其中所有目录与文件）
        private static void deleteFile(File file) {
            if (file.isFile()) {
                file.delete();
            } else if (file.isDirectory()) {

                //获取目录下的子文件对象
                File[] listFiles = file.listFiles();
                for (File f : listFiles) {
                    deleteFile(f);
                }

                //删除目录本身
                file.delete();
            }
        }
        */

        System.out.println(&quot;======判断操作======&quot;);

        File file08 = new File(&quot;D:\\Test\\Test2.txt&quot;);
        File file09 = new File(&quot;D:\\Test\\Test02\\Test&quot;);
        System.out.println(file08.exists());
        System.out.println(file09.exists());

        System.out.println(&quot;====================&quot;);

        //判断是否是文件
        System.out.println(file03.isFile());//因为被删除所以输出false
        System.out.println(file04.isFile());

        System.out.println(&quot;====================&quot;);

        //判断是否是文件夹
        System.out.println(file03.isDirectory());
        System.out.println(file04.isDirectory());

        System.out.println(&quot;====================&quot;);

        File file10 = new File(&quot;D:\\Test&quot;);
        String[] list = file10.list();//获取当前目录下的文件名以及文件夹名
        for (String string : list) {
            System.out.print(string + &quot;\t&quot;);
        }

        System.out.println();

        File[] listFiles = file10.listFiles();//获取当前目录下的文件对象
        for (File file : listFiles) {
            //文件名--是否是文件夹--是否是文件
            System.out.println(file.getName() + &quot;--&quot; + file.isDirectory() + &quot;--&quot; + file.isFile());
        }
    }
}</code></pre>
<h2 id="IO体系"><a href="#IO体系" class="headerlink" title="IO体系"></a>IO体系</h2><p>&emsp;<strong>IO流基本划分：</strong></p>
<ul>
<li>1.按照操作的数据类型：字节流、字符流</li>
<li>2.按照流的流向：输入流、输出流</li>
<li>3.按照流的角色：节点流、处理流</li>
</ul>
<table>
<thead>
<tr>
<th align="left"><label style="color:#ff4e6a">抽象对象</label></th>
<th align="left"><label style="color:#ff4e6a">节点流（文件流）</label></th>
<th align="left"><label style="color:#ff4e6a">缓冲流（属于处理流的一种）</label></th>
</tr>
</thead>
<tbody><tr>
<td align="left">InputStream（字节）</td>
<td align="left">FileInputStream (read()、read(byte[] bbuf))</td>
<td align="left">BufferedInputStream (read(byte[] bbuf))</td>
</tr>
<tr>
<td align="left">OutputStream</td>
<td align="left">FileOutPutStream (write(byte[] bbuf)、write(byte[] bbuf,int offset,int len))</td>
<td align="left">BufferedOutputStream (write(byte[] bbuf,int offset,int len))</td>
</tr>
<tr>
<td align="left">Reader（字符）</td>
<td align="left">FileReader (read()、read(char[] cbuf))</td>
<td align="left">BufferedReader (read(char[] cbuf)、readLine())</td>
</tr>
<tr>
<td align="left">Writer</td>
<td align="left">FileWriter (write(char[] cbuf,int offset,int len)、write(String str))</td>
<td align="left">BufferedWriter (write(char[] cbuf,int offset,int len)、write(String str)、newLine())</td>
</tr>
</tbody></table>
<h4 id="1-字符流"><a href="#1-字符流" class="headerlink" title="1.字符流"></a>1.字符流</h4><p>1.字符文件流<br>(1).字符文件输入流 FileReader</p>
<p><strong>方法</strong></p>
<ul>
<li>int &emsp;<label style="color:#ff4e6a">read()</label><br>读取单个字符 [返回值为读取的单个字符的ascii，如果返回-1代表到达流的末尾]</li>
</ul>
<ul>
<li>int &emsp;<label style="color:#ff4e6a">read(char[] cbuf)</label><br>将字符读入一个数组 [返回值代表读取的字符数量，如果返回-1代表到达流的末尾]</li>
</ul>
<ul>
<li>abstract int &emsp;<label style="color:#ff4e6a">read(char[] cbuf, int off, int len)</label><br>将字符读入一个数组的一部分</li>
</ul>
<p>需求：需要读取文件中字符内容</p>
<pre><code class="java">package com.greedring;

import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.File;
import java.io.IOException;

public class Test {
    public static void main(String[] args) {
        FileReader reader = null;
        //创建文件对象
        File file = new File(&quot;D:\\Test\\Test.txt&quot;);
        try {
            //创建字符（文件）输入流对象
            reader = new FileReader(file);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

        //方法一：逐个字符进行读取
        /*
        try {
            assert reader != null;//断言，避免空指针
            //read()读取单个字符 ascii
            int read = reader.read();
            while (read != -1) {
                System.out.print((char) read);
                read = reader.read();
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            //关闭资源（流对象不会自动关闭，也不会被垃圾回收机制回收），流对象使用完毕之后需要手动进行关闭
            try {
                assert reader != null;
                reader.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        */


        //方法一，进行优化，避免代码冗余
        /*
        try {
            int read;
            assert reader != null;//断言
            while ((read = reader.read()) != -1) {
                System.out.print((char) read);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            //关闭资源
            try {
                assert reader != null;
                reader.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        */


        //方式二：通过数组每次读取多个字符
        //定义读取字符的数组，数组长度需要适当，对大文件一般设为1024
        char[] cbuf = new char[5];
        int len;
        try {
            assert reader != null;//断言，避免空指针

            //注意：如果最后一次读取时，剩余字符无法占满一个数组，将在尾部产生上一次读取的字符，影响输出结果
            //去除尾部多余字符
            while ((len = reader.read(cbuf)) != -1) {
                for (int i = 0; i &lt; len; i++) {
                    System.out.print(cbuf[i]);
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            //关闭资源（流对象不会自动关闭，也不会被垃圾回收机制回收），流对象使用完毕之后需要手动进行关闭
            try {
                assert reader != null;
                reader.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}</code></pre>
<p>(2).字符文件输出流 FileWriter</p>
<ul>
<li>void &emsp;<label style="color:#ff4e6a">write(Object object)</label><br>写入字符</li>
</ul>
<ul>
<li>void &emsp;<label style="color:#ff4e6a">输出流对象.flush()</label><br>将输出流中的存储刷新进文件中（缓冲流满时和close关闭时会自动刷新进文件中）[多进程编程需要flush]</li>
</ul>
<p>需求：将内存中数据写入磁盘中</p>
<pre><code class="java">package com.greedring;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

public class Test {
    public static void main(String[] args) {
        //创建输出流对象（字符）FileWriter
        FileWriter fileWriter = null;

        //创建文件对象（指定文件位置用于写入）
        //如果文件不存在，那么会自动创建文件，并将内容写入到文件中，不会报错
        File file = new File(&quot;D:\\Test\\Test.txt&quot;);

        try {
            //注意：fileWriter.write(File file)会覆盖文件内容 [默认append false]
            //fileWriter.write(File file, append true)在原文件后拼接
            fileWriter = new FileWriter(file);
            //写入
            fileWriter.write(&quot;おい、この先は地狱だぜ！\n&quot;);// \n为转义字符：换行
            char[] chars = {&#39;次&#39;, &#39;は&#39;, &#39;本&#39;, &#39;当&#39;, &#39;の&#39;, &#39;地&#39;, &#39;獄&#39;, &#39;で&#39;, &#39;す&#39;};
            fileWriter.write(chars);//&quot;次は本当の地獄です&quot;.toCharArray()
            //fileWriter.flush();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            //关闭资源
            try {
                assert fileWriter != null;//断言
                fileWriter.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}</code></pre>
<p>(3).字符文件输入流与输出流同时使用<br>需求：使用字符流进行文本文件拷贝</p>
<pre><code class="java">package com.greedring;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

public class Test {
    public static void main(String[] args) {
        //文本文件拷贝，边读边写
        File srcFile = new File(&quot;D:\\Test\\Test.txt&quot;);//源文件
        File destFile = new File(&quot;D:\\Test\\Test1.txt&quot;);//目的文件

        FileReader fileReader = null;//创建输入流对象
        FileWriter fileWriter = null;//创建输出流对象

        try {
            fileReader = new FileReader(srcFile);
            fileWriter = new FileWriter(destFile);
        } catch (IOException e) {
            e.printStackTrace();
        }

        //读文件
        char[] cbuf = new char[5];
        int len;
        try {
            assert fileReader != null;
            while ((len = fileReader.read(cbuf)) != -1) {
                assert fileWriter != null;
                //写文件
                //fw.write(cbuf); 拷贝之后的文件会出现脏数据
                fileWriter.write(cbuf, 0, len);
                //fileWriter.flush();
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            //关闭资源
            try {
                assert  fileWriter != null;
                fileWriter.close();
                assert fileReader != null;
                fileReader.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}</code></pre>
<blockquote>
<p><strong>注意：</strong><br>对于文本文件（.txt .java .c .cpp…）可以使用字符流传输<br>对于非文本文件（.png .avi .jpg .word…）必须使用字节流传输</p>
</blockquote>
<h4 id="2-字节流"><a href="#2-字节流" class="headerlink" title="2.字节流"></a>2.字节流</h4><p>1.字节文件流<br>(1).字节输入流 FileInputStream<br>需求：读取文本文件</p>
<pre><code class="java">package com.greedring;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

public class Test {
    /**
    *如果文件中包含中文，可能发生乱码
    *原因：中文字符在UTF-8编码格式下，占用3个字节。在GBK格式编码下，占用2个字节。
    *所以发生读取字节的时候，将一个中文分两次读取出来
    */
    public static void main(String[] args) {
        File file = new File(&quot;D:\\Test\\Test.txt&quot;);//创建文件对象
        FileInputStream fis = null;//创建字节输入流对象
        try {
            fis = new FileInputStream(file);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
        //读取文件
        byte[] bbuf = new byte[5];
        int len;
        try {
            assert fis != null;
            while ((len = fis.read(bbuf)) != -1) {
                String string = new String(bbuf, 0, len);
                System.out.print(string);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                //关闭资源
                assert fis != null;
                fis.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}</code></pre>
<p>(2).字节输出流 FileOutputStream<br>因为输出方法和字符流类似，这里直接演示边读边写<br>需求：使用字节流进行文本文件拷贝</p>
<pre><code class="java">package com.greedring;

import java.io.*;

public class Test {
    public static void main(String[] args) {
        //使用字节流拷贝文件文件
        //创建源文件以及目的文件对象
        File srcFile = new File(&quot;D:\\Test\\Test.txt&quot;);
        File destFile = new File(&quot;D:\\Test\\Test1.txt&quot;);
        //创建字节输入流（读）以及输出流（写）对象
        FileInputStream fis = null;
        FileOutputStream fos = null;

        try {
            fis = new FileInputStream(srcFile);
            fos = new FileOutputStream(destFile);//FileOutputStream(destFile,true);拼接
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

        //边读边写
        byte[] bbuf = new byte[5];
        int len;
        try {
            //读取数据
            assert fis != null;
            while ((len = fis.read(bbuf)) != -1) {
                //写入数据（注意：脏数据问题）
                assert fos != null;
                fos.write(bbuf, 0, len);
                //fos.flush();
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            //关闭资源
            try {
                assert fos != null;
                fos.close();
                assert fis != null;
                fis.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}</code></pre>
<p>(3).字节流封装拷贝文件<br>既能拷贝文本(字符)文件、又能拷贝非本文(字节)文件</p>
<pre><code class="java">package com.greedring;

import java.io.*;

public class Test {
    public static void main(String[] args) {
        copyFile(&quot;D:\\Test\\Bismarck.jpg&quot;, &quot;D:\\Test\\Test1\\KMS Bismarck battleship.jpg&quot;);
        copyFile(&quot;D:\\Test\\Test.txt&quot;, &quot;D:\\Test\\Test1\\Test1.txt&quot;);
    }

    private static void copyFile(String srcPath, String destPath) {
        //创建源文件以及目的文件对象
        File src = new File(srcPath);
        File dest = new File(destPath);
        //创建字节输入流（读）以及输出流（写）对象
        FileInputStream fis = null;
        FileOutputStream fos = null;
        try {
            fis = new FileInputStream(src);
            fos = new FileOutputStream(dest);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
        //边读边写
        byte[] bbuf = new byte[1024];
        int len;

        try {
            //读取数据
            assert fis != null;
            while ((len = fis.read(bbuf)) != -1) {
                //写入数据（注意：脏数据问题）
                assert fos != null;
                fos.write(bbuf, 0, len);
                //fos.flush();
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            //关闭资源
            try {
                assert fos != null;
                fos.close();
                assert fis != null;
                fis.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}</code></pre>
<h4 id="缓冲流（高效流）"><a href="#缓冲流（高效流）" class="headerlink" title="缓冲流（高效流）"></a>缓冲流（高效流）</h4><p>作用：提高数据的读取与写入的效率</p>
<blockquote>
<p>提高效率的原因（以字节缓冲流为例）：<br>因为缓冲流内置了缓冲区，缓冲区默认是8192长度的字节、字符数组<br>当每次write操作中，如果缓冲区满了，就会自动将数据刷新到文件中<br>当调用close方法时，也会自动将数据刷新到文件中</p>
</blockquote>
<blockquote>
<p>特点：需要“包装”在节点流上<br>高效流使用普通流对象作为构造方法参数。<br>将普通流包装，提供高效的装饰。（装饰模式）</p>
</blockquote>
<blockquote>
<p>&emsp;创建格式</p>
<ul>
<li><strong>字节流：</strong><br>BufferedInputStream 缓冲输入流对象 = new BufferedInputStream(输入流对象);<br>BufferedOutputStream 缓冲输出流对象 = new BufferedOutStream(输出流对象);</li>
</ul>
<ul>
<li><strong>字符流：</strong><br>BufferedReader 缓冲输入流对象 = new BufferedReader(输入流对象);<br>BufferedWriter 缓冲输出流对象 = new BufferedWriter(输出流对象);</li>
</ul>
</blockquote>
<pre><code class="java">package com.greedring;

import java.io.*;
import java.util.Date;

public class Test {
    public static void main(String[] args) {
        long startTime = new Date().getTime();//记录字节流拷贝开始时间
        copyFile(&quot;D:/Test/PINK_CAT.mp4&quot;, &quot;D:/Test/Test1/pink_cat.mp4&quot;);
        long endTime = System.currentTimeMillis();//记录字节流拷贝结束时间
        System.out.println(&quot;使用缓冲流拷贝字节流文件耗时：&quot; + (endTime - startTime) + &quot;ms&quot;);

        long startTime1 = new Date().getTime();//记录字符流拷贝开始时间
        copyTxtFile(&quot;D:/Test/Test.txt&quot;, &quot;D:/Test/Test1/Test1.txt&quot;);
        long endTime1 = System.currentTimeMillis();//记录字符流拷贝结束时间
        System.out.println(&quot;使用缓冲流拷贝字符流文件耗时&quot; + (endTime1 - startTime1) + &quot;ms&quot;);
    }

    //使用缓冲流实现字节流文件拷贝
    private static void copyFile(String str, String dest) {
        //创建输入、输出文件对象
        File srcFile = new File(str);
        File destFile = new File(dest);
        //创建缓冲输入流、输出流对象
        BufferedInputStream bis;
        BufferedOutputStream bos;
        //创建字节输入流、输出流对象
        FileInputStream fis = null;
        FileOutputStream fos = null;
        try {
            fis = new FileInputStream(srcFile);
            fos = new FileOutputStream(destFile);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

        assert fis != null;
        bis = new BufferedInputStream(fis);
        assert fos != null;
        bos = new BufferedOutputStream(fos);
        byte[] bbuf = new byte[1024];
        int len;
        try {
            while ((len = bis.read(bbuf)) != -1) {
                bos.write(bbuf, 0, len);
                //bos.flush();
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                //关闭资源，先关闭外层流，再关闭内层流
                bos.close();
                bis.close();
                /*
                 *默认关闭外层流，就会自动关闭内层流
                 * fos.close(); fis.close();
                 */
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    //使用缓冲流实现字符流文件拷贝
    private static void copyTxtFile(String str, String dest) {
        //创建输入、输出文件对象
        File strFile = new File(str);
        File destFile = new File(dest);
        //创建缓冲输入流、输出流对象
        BufferedReader br;
        BufferedWriter bw;
        //创建字符输入流、输出流对象
        FileReader fr = null;
        FileWriter fw = null;
        try {
            fr = new FileReader(strFile);
            fw = new FileWriter(destFile);
        } catch (IOException e) {
            e.printStackTrace();
        }

        assert fr != null;
        br = new BufferedReader(fr);
        assert fw != null;
        bw = new BufferedWriter(fw);
        char[] cbuf = new char[1024];
        int len;
        try {
            while ((len = br.read(cbuf)) != -1) {
                bw.write(cbuf, 0, len);
                //bw.flush();
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                bw.close();
                br.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}</code></pre>
<h4 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h4><p>作用：提供了将字节流转换为字符流的一种方式</p>
<p>Reader:<br>    InputStreamReader可以完成字节输入流转换为字符输入流<br>Writer:<br>    OutputStreamWriter可以完成字节输出流转换为字符输出流</p>
<p>编码：字符、字符数组=&gt; 码表 =&gt;字节、字节数组<br>解码：字节、字节数组=&gt; 码表 =&gt;字符、字符数组</p>
<pre><code class="java">package com.greedring;

import java.io.*;

public class Test {
    public static void main(String[] args) {
        //创建文件对象
        File srcFile = new File(&quot;D:/Test/Test.txt&quot;);
        File destFile = new File(&quot;D:/Test/Test1/Test1.txt&quot;);
        //创建转换流
        InputStreamReader isr = null;
        OutputStreamWriter osw = null;
        try {
            //创建文件字节流输入、输出对象
            FileInputStream fis = new FileInputStream(srcFile);
            FileOutputStream fos = new FileOutputStream(destFile);
            //将字节输入流、输出流转换为字符输入、输出流
            isr = new InputStreamReader(fis);
            osw = new OutputStreamWriter(fos);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

        //使用字符流方式读取与写入
        char[] cbuf = new char[1024];
        int len;
        try {
            assert isr != null;
            while ((len = isr.read(cbuf)) != -1) {
                osw.write(cbuf, 0, len);
                //osw.flush();
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                //关闭转换流会默认关闭字节流
                assert isr != null;
                isr.close();
                osw.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}</code></pre>
<h4 id="其他流"><a href="#其他流" class="headerlink" title="其他流"></a>其他流</h4><p><strong>1.对象序列化与反序列化【掌握】</strong><br>&emsp;&emsp;序列化机制就是允许将内存中的Java对象转换为与平台无关的二进制数据，可以将这些二进制数据永久地存储在磁盘的文件中，或者通过网络传输到其他网络节点。只要其他程序获取到了这些二进制数据，就可以把数据再次转换为对象</p>
<blockquote>
<p>用于向流中写入对象的操作流 ObjectOutputStream称为序列化流<br>用于从流中读取对象的操作流 ObjectInputStream称为反序列化流<br>特点：用于操作对象。可以将对象写入到文件中，也可以从文件中读取对象。</p>
</blockquote>
<p>&emsp;&emsp;&emsp;&emsp;将自定义对象、String进行持久化（保存到文件中）&emsp; ==&gt; &emsp;&emsp;序列化<br>&emsp;&emsp;&emsp;&emsp;将文件中内容读取转换为自定义对象&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; ==&gt; &emsp;&emsp;反序列化</p>
<blockquote>
<ul>
<li><strong>ObjectOutputStream序列化流</strong><br><label style="color:#ff4e6a">public final void writeObject(Object  obj)</label><br>ObjectOutputStream将Java对象写入OutputStream，利用输出流将对象写入到指定的文件中。</li>
</ul>
<ul>
<li><strong>ObjectInputStream反序列化流</strong><br><label style="color:#ff4e6a">public final Object readObject()</label><br>ObjectInputStream将InputStream中数据转换为对象，利用输入流从文件中读取对象</li>
</ul>
</blockquote>
<p><strong>&emsp;&emsp;<label style="color:#ff4e6a">注意点：</label></strong></p>
<ul>
<li>如果一个对象需要支持序列化与反序列化，那么该对象所属的类必须实现Serializable接口（类对应的对象具有了序列化与反序列化的能力）</li>
</ul>
<ul>
<li>需要实现序列化的类需要提供个serialVersionUID（如果没有提供，那么JVM会自动提供。每次修改类，该值都会发生变化）<br>Java的序列化机制是通过判断类的serialVersionUID来验证版本一致性的。</li>
</ul>
<ul>
<li>如果一个类需要支持序列化与反序列化操作那么这个类中的所有属性也需要支持序列化与反序列化</li>
</ul>
<ul>
<li>被 <label style="color:#ff4e6a">static</label> 与 <label style="color:#ff4e6a">transient</label> 关键字修饰的属性无法被序列化</li>
</ul>
<pre><code class="java">package com.greedring;

import java.io.*;

public class Test {
    public static void main(String[] args) {
        //序列化操作 内存=&gt;文件
        //创建写出文件对象
        File src = new File(&quot;Ride on.txt&quot;);
        //创建序列化对象
        ObjectOutputStream oos = null;
        try {
            oos = new ObjectOutputStream(new FileOutputStream(src));
        } catch (IOException e) {
            e.printStackTrace();
        }
        try {
            //将对象写入输出流
            assert oos != null;
            oos.writeObject(&quot;重装小兔19C UP GRADE!\n&quot;);
            //自定义对象如果需要实习序列化操作，必须实现Serializable接口
            oos.writeObject(new Person(&quot;Bronya_Zaychik&quot;, 14, new Pet(&quot;重装小兔19C&quot;, 3)));
            //oos.flush();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                //关闭资源
                assert oos != null;
                oos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        ReadObject();
    }

    //反序列化 文件=&gt;内存(对象)
    private static void ReadObject() {
        //创建读取文件对象
        File dest = new File(&quot;Ride on.txt&quot;);
        //创建对象读取流(通过输入构造流)
        ObjectInputStream ois = null;
        try {
            ois = new ObjectInputStream(new FileInputStream(dest));
        } catch (IOException e) {
            e.printStackTrace();
        }

        try {
            //读取文件获得对象
            //readObject顺序需要按照writeObject的顺序
            assert ois != null;
            String str = (String) ois.readObject();
            Person person = (Person) ois.readObject();
            System.out.print(str);
            System.out.print(person);
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        } finally {
            try {
                //关闭资源
                assert ois != null;
                ois.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    public static class Pet implements Serializable {
        private static final long serialVersionUID = 124523457341534L;
        private String name;
        private int age;

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public int getAge() {
            return age;
        }

        public void setAge(int age) {
            this.age = age;
        }

        public Pet(String name, int age) {
            this.name = name;
            this.age = age;
        }

        public Pet() {
        }

        @Override
        public String toString() {
            return &quot;Pet{&quot; +
                    &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                    &quot;, age=&quot; + age +
                    &#39;}&#39;;
        }
    }

    public static class Person implements Serializable {
        private static final long serialVersionUID = 4357459356L;
        private static String id = &quot;1&quot;;//static修饰的属性无法实现序列化
        private String name;
        private transient int age;//transient修饰的属性无法实现序列化
        private Pet pet;

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public int getAge() {
            return age;
        }

        public void setAge(int age) {
            this.age = age;
        }

        public Pet getPet() {
            return pet;
        }

        public void setPet(Pet pet) {
            this.pet = pet;
        }

        Person(String name, int age, Pet pet) {
            this.name = name;
            this.age = age;
            this.pet = pet;
        }

        public Person() {
        }

        @Override
        public String toString() {
            return &quot;Person{&quot; +
                    &quot;id=&#39;&quot; + id + &#39;\&#39;&#39; +
                    &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
                    &quot;, age=&quot; + age +
                    &quot;, pet=&quot; + pet +
                    &#39;}&#39;;
        }
    }
}</code></pre>
<p>2.标准的输入流、标准输出流【了解】</p>
<blockquote>
<p>System.in    标准输入流（键盘）<br>System.out   标准输出流（控制台）</p>
</blockquote>
<pre><code class="java">package com.greedring;

import java.io.*;

public class Test {
    public static void main(String[] args) {
        // 标准输出流
        // System.out.println(&quot;hello world&quot;);

        // 标准输入流 System.in
        // 之前是借助java.util.Scanner nextLine()
        /*
         * 从控制台接受一个字符串，将字符串转换为大写并输出 当输入e 或者 exit 退出程序
         */
        // 字符输入流
        InputStreamReader isr = new InputStreamReader(System.in);

        BufferedReader br = new BufferedReader(isr);

        while (true) {
            System.out.println(&quot;请输入字符串:&quot;);
            /*
             * char[] cbuf = new char[1024]; int len = isr.read(cbuf); String str = new String(cbuf, 0, len);
             */

            String str = null;
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }

            assert str != null;
            //trim()删除字符串头尾空格
            if (&quot;e&quot;.equalsIgnoreCase(str.trim()) || &quot;exit&quot;.equalsIgnoreCase(str.trim())) {
                // 关闭资源
                try {
                    br.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
                System.exit(0);
            }
            //将小写字符转化为大写
            String upperCase = str.toUpperCase();
            System.out.println(upperCase);
        }
    }
}</code></pre>
<p>3.打印流【了解】</p>
<blockquote>
<p>打印流只有输出流<br>PrintStream    字节打印流，调用println方法时自动刷新<br>PrintWriter    字符打印流，指定自动刷新开关后，调用println方法时自动刷新，无需手动调用flush()方法。</p>
</blockquote>
<pre><code class="java">package com.greedring;

import java.io.*;

public class Test {
    public static void main(String[] args) throws FileNotFoundException {
        //字节打印流
        /*
        PrintStream ps = new PrintStream(new File(&quot;Test.txt&quot;));
        ps.write(&#39;a&#39;);
        ps.print(&quot;GreedRing&quot;);
        ps.close();

        PrintStream out = System.out;
        out.print(&quot;abc&quot;);
        */

        /*
         static void setOut(PrintStream out) 
         将标准输出流。 
         */
        //改变默认标准输出位置（Test.txt）
        System.setOut(new PrintStream(new File(&quot;Test.txt&quot;)));
        System.out.println(&quot;GreedRing&quot;);
        System.out.println(&quot;abc&quot;);
        System.out.println(24);
        System.out.println(true);
        //System.out.flush();

        //字符打印流
        PrintWriter pw = new PrintWriter(new File(&quot;Test1.txt&quot;));
        pw.write(&quot;行くぞ！&quot;);
        pw.write(&quot;\n&quot;);
        pw.print(&quot;Ring&quot;);
        pw.close();
    }
}</code></pre>

  </article>
  
    
<div class="nexmoe-post-copyright">
<i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
<strong>本文作者：</strong>GreedRing<br>
<strong>本文链接：</strong><a href="http://greedring.com/2019/09/17/JavaSE20/" title="http://greedring.com/2019/09/17/JavaSE20/" target="_blank" rel="noopener">http://greedring.com/2019/09/17/JavaSE20/</a><br>

  <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可

</div>


  
  <section class="nexmoe-comment">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.5.0/dist/gitalk.min.css">
<div id="gitalk"></div>
<script src="https://cdn.jsdelivr.net/npm/gitalk@1.5.0/dist/gitalk.min.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: '192a24997642e3747506',
        clientSecret: '54617c6a7809ea7b74d1d9d215e1b31a734c25ff',
        id: window.location.pathname,
        repo: 'greedring.github.io',
        owner: 'GreedRing',
        admin: 'GreedRing'
    })
    gitalk.render('gitalk')
</script>
</section>
</div>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/mdui@0.4.3/dist/js/mdui.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
 
    <script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>


 
    <script src="https://cdn.jsdelivr.net/npm/smoothscroll-for-websites@1.4.9/SmoothScroll.min.js"></script>


<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.15.8/build/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script src="/js/app.js?v=1569175824280"></script>
<script src="https://cdn.jsdelivr.net/npm/lazysizes@5.1.0/lazysizes.min.js"></script>


    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/xtaodada/xtaodada.github.io@0.0.2/copy.js"></script>

  





</body>

</html>
